{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
#
# Smart Contract for Price Oracles and Emergency Oracles of Neutrino Protocol
#  

#-------------------Base functions----------------------
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: Address, key: String) = {
    match getInteger(address, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: Address, key: String) = {
     match getString(address, key) {
            case a:String => a
            case _ => ""
    }
}

func dropElementInJsonArray(array: String, element: String) = {
    let splitedArray = array.split(element)
    if(splitedArray[1].take(1) == ",") then
        splitedArray[0] + splitedArray[1].drop(1)
    else
        splitedArray[0].dropRight(1) + splitedArray[1]
}
func convertJsonArrayToList(jsonArray: String) = {
   jsonArray.split(",") #jsonArray.take(size(jsonArray)-1).drop(1).split(",")
}

#-------------------Constants--------------------------- 
let BLOCK = "block"
let CONFIRMTX = "confirm_tx"
let NONE = "none"

#-------------------Constructor-------------------------
let OraclesKey = "oracles"
let AdminsKey = "admins"
let VoteIntervalKey = "vote_interval"
let CoefficientOracleKey = "coefficient_oracle"
let CoefficientAdminKey = "coefficient_admin"
let ScriptUpdateIntervalKey = "script_update_interval"
let PriceOffsetKey = "price_offset"

#-------------------Keys---------------------------------
#------This contract----------
let PriceKey = "price"
let IsBlockedKey = "is_blocked"
let BlockExpireVoteKey = "vote_expire_block"
let ScriptUpdateBlockKey = "script_update_block"
let PriceIndexKey = "price_index"
let LastConfirmTxKey = "last_confirm_tx"

func getAdminVoteKey(owner: String) = "admin_vote_" + owner
func getAdminVoteArgumentsKey(owner: String) = "vote_action_" + owner + "_arguments"
func getBlackSwarmPriceKey(block: Int) = "black_swarm_price" + "_" + toString(block)
func getPriceHistoryKey(block: Int) = PriceKey + "_" + toString(block)
func getHeightPriceByIndexKey(index: Int) = PriceIndexKey + "_" + toString(index)
func getOracleProvidePriceKey(height: Int) = "price_" + toString(height)

#-------------------Global vars-------------------------
let price = getNumberByKey(PriceKey)
let priceIndex = getNumberByKey(PriceIndexKey)
let isBlocked = getBoolByKey(IsBlockedKey)
let bftCoefficientOracle = getNumberByKey(CoefficientOracleKey)
let bftCoefficientAdmin = getNumberByKey(CoefficientAdminKey)
let percentPriceOffset = getNumberByKey(PriceOffsetKey)
let voteInterval = getNumberByKey(VoteIntervalKey)
let blockExpireVote = getNumberByKey(BlockExpireVoteKey)
let oracles = getStringByKey(OraclesKey)
let admins = getStringByKey(AdminsKey)
let oraclesList = convertJsonArrayToList(oracles) 
let adminsList = convertJsonArrayToList(admins) 
let lastConfirmTx = getStringByKey(LastConfirmTxKey)

#-------------------Get func----------------------------
func getAdminVote(owner: String) = getStringByKey(getAdminVoteKey(owner))
func getAdminVoteArguments(owner: String) = getStringByKey(getAdminVoteArgumentsKey(owner))
func getOracleProvideHeight(owner: String, height: Int) = getNumberByAddressAndKey(addressFromStringValue(owner), getOracleProvidePriceKey(height))
func getPriceHistory(height: Int) = getNumberByKey(getPriceHistoryKey(height))
#-------------------Other func--------------------------
func isOracle(address: String) = {
    isDefined(indexOf(oracles, address))
}
func isAdmin(address: String) = {
    isDefined(indexOf(admins, address))
}
#-------------------Fold func--------------------------
func foldSummByAction(result: Int, address: String, action: String) = 
    if(getAdminVote(address) == action) then 1 else 0

func foldSummByBlock(result: Int, address: String) =
   foldSummByAction(result, address, BLOCK)

func foldSummByConfirmTx(result: Int, address: String) =
   foldSummByAction(result, address, CONFIRMTX)

func summByAction(admins: List[String], action: String) = {
    if(action == BLOCK) 
        then FOLD<5>(admins, 0, foldSummByBlock)
    else if(action == CONFIRMTX)
        then FOLD<5>(admins, 0, foldSummByConfirmTx)
    else throw("-")
}

func summByArguments(admins: List[String], arguments: String) = {
    (if(getAdminVoteArguments(admins[0]) == arguments) then 1 else 0) +
    (if(getAdminVoteArguments(admins[1]) == arguments) then 1 else 0) +
    (if(getAdminVoteArguments(admins[2]) == arguments) then 1 else 0) +
    (if(getAdminVoteArguments(admins[3]) == arguments) then 1 else 0) +
    (if(getAdminVoteArguments(admins[4]) == arguments) then 1 else 0)
}
#-------------------Callable----------------------

# [called by price oracles]
@Callable(i)
func finalizeCurrentPrice() = {
    let prices = [
        getOracleProvideHeight(oraclesList[0], height),
        getOracleProvideHeight(oraclesList[1], height),
        getOracleProvideHeight(oraclesList[2], height),
        getOracleProvideHeight(oraclesList[3], height),
        getOracleProvideHeight(oraclesList[4], height)
    ]                  

    let priceProvidingCount = 
        (if(prices[0] != 0) then 1 else 0) +
        (if(prices[1] != 0) then 1 else 0) + 
        (if(prices[2] != 0) then 1 else 0) +
        (if(prices[3] != 0) then 1 else 0) +
        (if(prices[4] != 0) then 1 else 0)

    let priceSum = prices[0] + prices[1] + prices[2] + prices[3] + prices[4]
    let newPrice = priceSum/priceProvidingCount

    if(isBlocked)
        then throw("contract is blocked")
    else if(getPriceHistory(height) != 0)
        then throw("wait next block")
    else if(priceProvidingCount < bftCoefficientOracle)
        then throw(toString(bftCoefficientOracle) + "/5 oracles need to set a price (" + toString(priceProvidingCount) + ")")
    else if(newPrice >= (price + price*percentPriceOffset/100) || newPrice <= (price - price*percentPriceOffset/100)) then {
        WriteSet([
            DataEntry(IsBlockedKey, true),
            DataEntry(getBlackSwarmPriceKey(height), newPrice)
        ])
    }
    else {
        let newPriceIndex = priceIndex + 1
        WriteSet([
            DataEntry(PriceKey, newPrice),
            DataEntry(getPriceHistoryKey(height), newPrice),
            DataEntry(PriceIndexKey, newPriceIndex),
            DataEntry(getHeightPriceByIndexKey(newPriceIndex), height)
        ])
    }
}

# [called by emergency oracles]
@Callable(i)
func vote(action: String, arguments: String) = {
    let account = toString(i.caller)
    let vote = getAdminVote(account)

    let voteCount = summByAction(adminsList, action) + 1
    let equalArgumentsCount = summByArguments(adminsList, arguments) + 1
    let isVotingEnded = height > blockExpireVote

    let resetResult = [
        DataEntry(BlockExpireVoteKey, 0),
        DataEntry(getAdminVoteKey(adminsList[0]), ""),
        DataEntry(getAdminVoteKey(adminsList[1]), ""),
        DataEntry(getAdminVoteKey(adminsList[2]), ""),
        DataEntry(getAdminVoteKey(adminsList[3]), ""),
        DataEntry(getAdminVoteKey(adminsList[4]), "")
    ]

    if(vote != "")
        then throw("-")
    else if(!isAdmin(account))
        then throw("")
    else if(voteCount >= bftCoefficientAdmin && equalArgumentsCount >= bftCoefficientAdmin && !isVotingEnded) then {
        if(action == BLOCK) then {
            let isBlocking = arguments == "true"
            WriteSet(
                cons(DataEntry(IsBlockedKey, isBlocking), resetResult)
            )
        }
        else if(action == CONFIRMTX) then {
            let id = arguments
            WriteSet(
                cons(DataEntry(LastConfirmTxKey, id), resetResult)
            )
        }
        else 
            throw("invalid action")
    }
    else {
        WriteSet([
            DataEntry(BlockExpireVoteKey, if(isVotingEnded) then height + voteInterval else blockExpireVote),
            DataEntry(getAdminVoteKey(adminsList[0]), if(isVotingEnded) then "" else getAdminVote(adminsList[0])),
            DataEntry(getAdminVoteKey(adminsList[1]), if(isVotingEnded) then "" else getAdminVote(adminsList[1])),
            DataEntry(getAdminVoteKey(adminsList[2]), if(isVotingEnded) then "" else getAdminVote(adminsList[2])),
            DataEntry(getAdminVoteKey(adminsList[3]), if(isVotingEnded) then "" else getAdminVote(adminsList[3])),
            DataEntry(getAdminVoteKey(adminsList[4]), if(isVotingEnded) then "" else getAdminVote(adminsList[4])),
            DataEntry(getAdminVoteKey(account), action),
            DataEntry(getAdminVoteArgumentsKey(account), arguments)
        ])
    }
}

@Verifier(tx)
func verify() = {
    lastConfirmTx == toBase58String(tx.id)
}
