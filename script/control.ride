{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# base function
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: Address, key: String) = {
    match getInteger(address, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: Address, key: String) = {
     match getString(address, key) {
            case a:String => a
            case _ => ""
    }
}

func dropElementInJsonArray(array: String, element: String) = {
    let splitedArray = array.split(element)
    if(splitedArray[1].take(1) == ",") then
        splitedArray[0] + splitedArray[1].drop(1)
    else
        splitedArray[0].dropRight(1) + splitedArray[1]
}

func convertJsonArrayToList(jsonArray: String) = {
   jsonArray.split(",") #jsonArray.take(size(jsonArray)-1).drop(1).split(",")
}
#end base function

#consts
let BLOCK = "block"
let UNBLOCK = "unblock"
let UPDATE = "update"
#end consts

#constructor
let OraclesKey = "oracles"
let AdminsKey = "admins"
let VoteIntervalKey = "vote_interval"
let CoefficientOracleKey = "coefficient_oracle"
let CoefficientAdminKey = "coefficient_admin"
let ScriptUpdateIntervalKey = "script_update_interval"
let ProvidingIntervalKey = "providing_interval"
#end constructor


# keys
let PriceKey = "price"
let PriceOffsetKey = "price_offset"
let IsNewPricePendingKey = "is_pending_price"
let IsBlockedKey = "is_blocked"
let HasOracleProvidedPriceKey = "oracle_is_provide_"
let PriceProvidedByOracleKey = "oracle_price_provide_"
let AdminVoteKey = "admin_vote_"
let ActionKey = "action"
let PriceFeedExpirationBlockKey = "providing_expire_block"
let CriticalPriceDropKey = "black_swarm_price"
let BlockExpireVoteKey = "vote_expire_block"
let ScriptUpdateBlockKey = "script_update_block"
let PriceIndexKey = "price_index"


func getHasOracleProvidedPriceKey(owner: String) = HasOracleProvidedPriceKey + owner
func getPriceProvidedByOracleKey(owner: String) = PriceProvidedByOracleKey + owner
func getAdminVoteKey(owner: String) = AdminVoteKey + owner
func getAdminVoteActionKey(owner: String) = getAdminVoteKey(owner) + "_" + ActionKey
func getCriticalPriceDropKey(block: Int) = CriticalPriceDropKey + "_" + toString(block)
func getPriceHistoryKey(block: Int) = PriceKey + "_" + toString(block)
func getHeightPriceByIndexKey(index: Int) = PriceIndexKey + "_" + toString(index)
#end keys

#global vars
let price = getNumberByKey(PriceKey)
let priceIndex = getNumberByKey(PriceIndexKey)
let providingInterval = getNumberByKey(ProvidingIntervalKey)
let priceFeedExpirationBlock = getNumberByKey(PriceFeedExpirationBlockKey)
let blockExpireVote = getNumberByKey(BlockExpireVoteKey)
let scriptUpdateBlock = getNumberByKey(ScriptUpdateBlockKey)
let scriptUpdateInterval = getNumberByKey(ScriptUpdateIntervalKey)
let isNewPricePending = getBoolByKey(IsNewPricePendingKey)
let isBlocked = getBoolByKey(IsBlockedKey)
let bftCoefficientOracle = getNumberByKey(CoefficientOracleKey)
let bftCoefficientAdmin = getNumberByKey(CoefficientAdminKey)
let percentPriceOffset = getNumberByKey(PriceOffsetKey)
let voteInterval = getNumberByKey(VoteIntervalKey)
let oracles = getStringByKey(OraclesKey) # json array
let admins = getStringByKey(AdminsKey) # json array
let oraclesList = convertJsonArrayToList(oracles) # json array
let adminsList = convertJsonArrayToList(admins) # json array
#end global vars

# get func
func getAdminVoteAction(owner: String) = getStringByKey(getAdminVoteActionKey(owner))
func hasOracleProvidedPrice(owner: String) = getBoolByKey(getHasOracleProvidedPriceKey(owner))
func hasOracleProvidedPriceInt(owner: String) = if(hasOracleProvidedPrice(owner)) then 1 else 0
func getOracleProvidePrice(owner: String) = getNumberByKey(getPriceProvidedByOracleKey(owner))
# end get func

#other func
func isOracle(address: String) = {
    isDefined(indexOf(oracles, address))
}
func isAdmin(address: String) = {
    isDefined(indexOf(admins, address))
}
#end other func

# FOLD func
func sumOraclePrice(base: Int, address: String) =
   base + getOracleProvidePrice(address)*hasOracleProvidedPriceInt(address)

func filterAdminsVoteByAction(result: List[String], address: String, action: String) =
   address :: result

func filterAdminsVoteByBlockAction(result: List[String], address: String) =
   filterAdminsVoteByAction(result, address, BLOCK)

func filterAdminsVoteByUnblockAction(result: List[String], address: String) =
   filterAdminsVoteByAction(result, address, UNBLOCK)

func filterAdminsVoteByUpdateAction(result: List[String], address: String) =
   filterAdminsVoteByAction(result, address, UPDATE)

#end FOLD func

#-------------------Callable----------------------

# [called by price oracles]
@Callable(i)
func setNewPrice(newPrice : Int) = {
    let account = toString(i.caller)
    let hasOracleProvidedPriceList = [
                                hasOracleProvidedPrice(oraclesList[0]),
                                hasOracleProvidedPrice(oraclesList[1]),
                                hasOracleProvidedPrice(oraclesList[2]),
                                hasOracleProvidedPrice(oraclesList[3]),
                                hasOracleProvidedPrice(oraclesList[4])
                            ]

    let priceProvidingCount =
        (if (hasOracleProvidedPriceList[0]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[1]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[2]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[3]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[4]) then 1 else 0) + 1

    if(isBlocked)
        then throw("contract is blocked")
    else if(!isOracle(account))
        then throw("permission denied")
    else if(height <= priceFeedExpirationBlock && hasOracleProvidedPrice(account))
        then throw("price is already provided")
    else if(height > priceFeedExpirationBlock && isNewPricePending)
        then throw("use confirmNewPrice")
    else {
        WriteSet([
            DataEntry(getHasOracleProvidedPriceKey(oraclesList[0]), if(height > priceFeedExpirationBlock) then false else hasOracleProvidedPriceList[0]),
            DataEntry(getHasOracleProvidedPriceKey(oraclesList[1]), if(height > priceFeedExpirationBlock) then false else hasOracleProvidedPriceList[1]),
            DataEntry(getHasOracleProvidedPriceKey(oraclesList[2]), if(height > priceFeedExpirationBlock) then false else hasOracleProvidedPriceList[2]),
            DataEntry(getHasOracleProvidedPriceKey(oraclesList[3]), if(height > priceFeedExpirationBlock) then false else hasOracleProvidedPriceList[3]),
            DataEntry(getHasOracleProvidedPriceKey(oraclesList[4]), if(height > priceFeedExpirationBlock) then false else hasOracleProvidedPriceList[4]),
            DataEntry(getHasOracleProvidedPriceKey(account), true),

            DataEntry(getPriceProvidedByOracleKey(account), newPrice),
            DataEntry(PriceFeedExpirationBlockKey, if(height > priceFeedExpirationBlock) then height + providingInterval else priceFeedExpirationBlock),
            DataEntry(IsNewPricePendingKey, if(height <= priceFeedExpirationBlock && priceProvidingCount >= bftCoefficientOracle) then true else isPricePending)
        ])
    }
}

# [called by price oracles]
@Callable(i)
func confirmNewPrice() = {
    let hasOracleProvidedPriceList = [
                                hasOracleProvidedPrice(oraclesList[0]),
                                hasOracleProvidedPrice(oraclesList[1]),
                                hasOracleProvidedPrice(oraclesList[2]),
                                hasOracleProvidedPrice(oraclesList[3]),
                                hasOracleProvidedPrice(oraclesList[4])
                            ]

    let priceProvidingCount =
        (if (hasOracleProvidedPriceList[0]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[1]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[2]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[3]) then 1 else 0) +
        (if (hasOracleProvidedPriceList[4]) then 1 else 0)

    let priceSum =
        (getOracleProvidePrice(oraclesList[0])*(if (hasOracleProvidedPriceList[0]) then 1 else 0)) +
        (getOracleProvidePrice(oraclesList[1])*(if (hasOracleProvidedPriceList[1]) then 1 else 0)) +
        (getOracleProvidePrice(oraclesList[2])*(if (hasOracleProvidedPriceList[2]) then 1 else 0)) +
        (getOracleProvidePrice(oraclesList[3])*(if (hasOracleProvidedPriceList[3]) then 1 else 0)) +
        (getOracleProvidePrice(oraclesList[4])*(if (hasOracleProvidedPriceList[4]) then 1 else 0))

    let newPrice = priceSum/priceProvidingCount

    if(isBlocked)
        then throw("contract is blocked")
    else if(!isNewPricePending || height <= priceFeedExpirationBlock)
        then throw("wait for the end of the price providing")
    else if(priceProvidingCount < bftCoefficientOracle)
        then throw("3/5 oracles need to set a price")
    else if(newPrice >= (price + price*percentPriceOffset/100) || newPrice <= (price - price*percentPriceOffset/100)) then {
        WriteSet([
            DataEntry(IsBlockedKey, true),
            DataEntry(getCriticalPriceDropKey(height), newPrice)
        ])
    }
    else {
        let newPriceIndex = priceIndex + 1
        WriteSet([
            DataEntry(PriceKey, newPrice),
            DataEntry(getPriceHistoryKey(height), newPrice),
            DataEntry(IsNewPricePendingKey, false),
            DataEntry(PriceIndexKey, newPriceIndex),
            DataEntry(getHeightPriceByIndexKey(newPriceIndex), height)
        ])
    }
}

# [called by emergency oracles]
@Callable(i)
func vote(action: String) = {
    let account = toString(i.caller)
    let adminsListWithoutAccount = convertJsonArrayToList(dropElementInJsonArray(admins, account))
    let lastAction = getAdminVoteAction(account)

    let blockVotes = FOLD<5>(adminsListWithoutAccount, [], filterAdminsVoteByBlockAction)
    let unblockVotes = FOLD<5>(adminsListWithoutAccount, [], filterAdminsVoteByUnblockAction)
    let updateVotes = FOLD<5>(adminsListWithoutAccount, [], filterAdminsVoteByUpdateAction)

    let blockVoteCount = size(blockVotes) + if( action == BLOCK) then 1 else 0
    let unblockVoteCount = size(unblockVotes) + if( action == UNBLOCK) then 1 else 0
    let updateVotesCount = size(updateVotes) + if( action == UPDATE) then 1 else 0

    let resetResult = [
        DataEntry(BlockExpireVoteKey, 0),
        DataEntry(PriceFeedExpirationBlockKey, 0),
        DataEntry(getAdminVoteActionKey(adminsListWithoutAccount[0]), ""),
        DataEntry(getAdminVoteActionKey(adminsListWithoutAccount[1]), ""),
        DataEntry(getAdminVoteActionKey(adminsListWithoutAccount[2]), ""),
        DataEntry(getAdminVoteActionKey(adminsListWithoutAccount[3]), "")
    ]
    if(blockVoteCount >= bftCoefficientAdmin || unblockVoteCount >= bftCoefficientAdmin) then {
        WriteSet(
            cons(
                DataEntry(IsNewPricePendingKey, false),
                cons(DataEntry(IsBlockedKey, if(blockVoteCount >= bftCoefficientAdmin) then true else false), resetResult)
            )
        )
    }
    else if(updateVotesCount > bftCoefficientAdmin) then {
        WriteSet(
            cons(DataEntry(ScriptUpdateBlockKey, if(updateVotesCount > bftCoefficientAdmin) then height + scriptUpdateInterval else scriptUpdateBlock), resetResult)
        )
    }
    else {
        WriteSet([
            DataEntry(BlockExpireVoteKey, if(height > blockExpireVote) then height + voteInterval else blockExpireVote),
            DataEntry(getAdminVoteActionKey(account), action)
        ])
    }
}
